/*
 * SimulatedEvolution.java
 *
 * Created on September 19, 2005, 7:21 PM
 */

package ca.umontreal.iro.evolution.genecontent;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Hashtable;


import ca.umontreal.iro.banality.BasicExecutable;
import ca.umontreal.iro.banality.Heap;
import ca.umontreal.iro.banality.Verbose;

import ca.umontreal.iro.matek.Pseudorandom;

/**
 * A class for generating simulated data.
 * 
 * @author  csuros
 */
public class SimulatedEvolution extends BasicExecutable
{
    
    public SimulatedEvolution(RateVariation rates) 
    {
        setRateVariation(rates);
    }
    
    private SimulatedEvolution()
    {
    }
    
    private void setRateVariation(RateVariation rates)
    {
        this.rates=rates;
        initDataStructures();
        
    }
    /**
     * Underlying rate model
     */
    private RateVariation rates;
    
    /**
     * The random number generator.
     */
    private Pseudorandom RND;

    private void initDataStructures()
    {
        RND=new Pseudorandom(new java.util.Random());
        int num_classes = rates.getNumClasses();
        class_cumulative_distribution = new double[num_classes];
        for (int cidx=0; cidx<num_classes; cidx++)
        {
            double pc = rates.getClassProbability(cidx);
            double previous_pc = (cidx==0?0.0:class_cumulative_distribution[cidx-1]);
            class_cumulative_distribution[cidx] = pc+previous_pc;
        }
    }
    
    private double[] class_cumulative_distribution;
    
    /**
     * Random rate category index
     * @return a valid class index drawn from uniform distribution
     */
    public int getRandomClassIndex()
    {
        double p = RND.nextUniform();
        int x=Arrays.binarySearch(class_cumulative_distribution, p);
        if (x<0) // binarysearch does not find this value: very likely
            x = -(x+1);
        // make sure that 0-probability classes are not picked
        while (x>0 && class_cumulative_distribution[x-1]>=p) x--;
        return x;
    }
    
    private double[] root_cumulative_distribution=null;
    
    
    private void setCumulativeDistribution(int max_value)
    {
        double[] pmf = rates.getRootPrior().getDistribution(max_value);
        root_cumulative_distribution = new double[max_value+1];
        root_cumulative_distribution[0] = pmf[0];
        for (int i=1; i<=max_value; i++)
            root_cumulative_distribution[i]=root_cumulative_distribution[i-1]+pmf[i];
    }
            
    private int getRandomRootSize(int class_idx)
    {
        if (root_cumulative_distribution == null)
            setCumulativeDistribution(2); // initial value; later it will be extended if necessary
        double p = RND.nextUniform();
        int x = -1;
        do
        {
            x=Arrays.binarySearch(root_cumulative_distribution, p);
            if (x<0) // binarysearch does not find this value: very likely
                x = -(x+1);
            if (x==root_cumulative_distribution.length)
                setCumulativeDistribution(2*(root_cumulative_distribution.length-1));
        } while (x==root_cumulative_distribution.length);
        return x;
    }

    /**
     * Generates a random profile from a given class
     * 
     * @param class_idx a rate category index
     * @return a random profile generated by the rate category's distribution 
     */
    public SimulatedProfile randomProfile(int class_idx)
    {
        TreeWithRates main_tree = rates.getMainTree();
        int num_nodes = main_tree.getNumNodes();
        int root_idx = num_nodes-1;
        SimulatedProfile P  = new SimulatedProfile();
        {
            // pick root size
            int root_size = getRandomRootSize(class_idx);
            
            // set rot size
            P.sizes[root_idx]= root_size;
        }
        TreeWithRates rate_tree = rates.getRateTree(class_idx);
        
        for (int node_idx=root_idx-1; node_idx>=0; node_idx--)
        {
            P.transfer_events[node_idx]
                    = P.duplication_events[node_idx]
                    = P.loss_events[node_idx]
                    = P.lineage_loss_events[node_idx]=0;
            NodeWithRates N = rate_tree.getNode(node_idx);
            double edge_length = N.getLength();
            double rate_transfer = N.getTransferRate();
            double rate_duplication = N.getDuplicationRate();
            double rate_loss = N.getLossRate();
            
            Mortal transfer_source = null;
            
            if (rate_transfer!=0.0)
                transfer_source = new Mortal();
            int parent_idx = main_tree.getParentIndex(node_idx);
            int parent_size = P.getSize(parent_idx);
            Heap<Mortal> population=new Heap<Mortal>();

            if (transfer_source != null)
            {
                population.add(transfer_source);
                transfer_source.setSpawnTime(RND.nextExponential(rate_transfer));
                //Verbose.message("SE.rP founder "+node_idx+"/"+N.newickName()+"\t[trans] "+transfer_source);
            }
            for (int i=0; i<parent_size; i++)
            {
                Mortal grandma = new Mortal();
                if (rate_duplication != 0.0)
                    grandma.setSpawnTime(RND.nextExponential(rate_duplication));
                if (rate_loss != 0.0)
                    grandma.setDeathTime(RND.nextExponential(rate_loss));
                population.add(grandma);                    
                //Verbose.message("SE.rP founder "+node_idx+"/"+N.newickName()+"\t["+population.size()+"] "+grandma);
            }
            while (!population.isEmpty()) // may be empty if there is no transfer and parent_size==0
            {
                Mortal subject = population.deleteMin();
                if (subject.getEventTime()>edge_length)
                    break;
                if (subject == transfer_source)
                {
                    //Verbose.message("SE.rP trans "+node_idx+"/"+N.getTaxonName()+"\t"+subject.toString());                
                    // surely a transfer
                    Mortal newcomer = subject.spawn();
                    subject.setSpawnTime(RND.nextExponential(rate_transfer));
                    population.add(subject);

                    if (rate_duplication != 0.0)
                        newcomer.setSpawnTime(RND.nextExponential(rate_duplication));
                    if (rate_loss != 0.0)
                        newcomer.setDeathTime(RND.nextExponential(rate_loss));
                    population.add(newcomer);                    
                    //Verbose.message("SE.rP transfer new "+newcomer+"\t"+subject);

                    P.transfer_events[node_idx]++;
                } else if (subject.dies())
                {
                    //Verbose.message("SE.rP loss  "+node_idx+"/"+N.getTaxonName()+"\t"+subject.toString());                
                    // nothing to do 
                    //Verbose.message("SE.rP loss "+subject);

                    P.loss_events[node_idx]++;
                } else // duplication: rate_duplication is surely not 0.0
                {
                    //Verbose.message("SE.rP dup   "+node_idx+"/"+N.getTaxonName()+"\t"+subject.toString());                
                    
                    Mortal newcomer = subject.spawn();
                    subject.setSpawnTime(RND.nextExponential(rate_duplication));
                    population.add(subject);

                    newcomer.setSpawnTime(RND.nextExponential(rate_duplication));
                    if (rate_loss != 0.0)
                        newcomer.setDeathTime(RND.nextExponential(rate_loss));
                    population.add(newcomer);

                    //Verbose.message("SE.rP duplication new "+newcomer+"\t"+subject);

                    P.duplication_events[node_idx]++;
                }
            }
            P.sizes[node_idx] = population.size();
            {
                // count lineages
                HashSet<Mortal> surviving_progenitors = new HashSet<Mortal>();
                while (!population.isEmpty())
                {
                    Mortal subject = population.deleteMin();
                    if (subject != transfer_source)
                        surviving_progenitors.add(subject.progenitor);
                }
                int num_lineages = surviving_progenitors.size();
                P.lineage_loss_events[node_idx] = 0;//(num_lineages==1 && ?1:0);//parent_size - num_lineages;
            }
        }

        P.setPatternAtLeaves();
        return P;
    }
    
    public OccurrenceTable randomTable(int maximum_family_size, int min_lineages, int num_families)
    {
        TreeWithRates main_tree = rates.getMainTree();
        NodeWithRates[] leaves = main_tree.getLeaves();
        int[][] table=new int[num_families][];
        ArrayList<Hashtable<String,Integer>> population_size_changes=new ArrayList<Hashtable<String,Integer>>();
        if (Verbose.isVerbose())
        {
            for (int i=0; i<main_tree.getNumEdges(); i++)
                population_size_changes.add(new Hashtable<String,Integer>());
        }
        
        int num_nodes = main_tree.getNumNodes();
        int num_edges = main_tree.getNumEdges();
        int[] total_present_1 = new int[num_nodes];
        int[] total_present_m = new int[num_nodes];
        int[] total_gain = new int[num_edges];
        int[] total_loss = new int[num_edges];
        int[] total_expansion = new int[num_edges];
        int[] total_reduction = new int[num_edges];
        
        int[] total_class = new int[rates.getNumClasses()];
        
        int num_missing = 0;
        
        for (int profile_idx=0; profile_idx<num_families; ) // profile_idx will be added later
        {
            int class_idx = getRandomClassIndex();
            
            SimulatedProfile P = randomProfile(class_idx);
            int num_absent = P.getAbsenceCount();
            if (Verbose.isVerbose())
            {
                StringBuffer stats = new StringBuffer("SE.rT EVENTS\t");
                stats.append(P.getPatternString());
                stats.append("\tRoot:");
                stats.append(Integer.toString(P.getSize(main_tree.getNumNodes()-1)));
                stats.append("\tGain:");
                for (int edge_idx=0; edge_idx<num_edges;edge_idx++)
                {
                    if (P.transfer_events[edge_idx]!=0)
                    {
                        stats.append('\t');
                        stats.append(Integer.toString(edge_idx));
                        stats.append('/');
                        stats.append(main_tree.getNode(edge_idx).newickName());
                        stats.append(".");
                        stats.append(P.transfer_events[edge_idx]);
                    }
                }
                //stats.append("\tLoss:");
                //for (int edge_idx=0; edge_idx<num_edges;edge_idx++)
                //{
                //    if (P.lineage_loss_events[edge_idx]!=0)
                //    {
                //        stats.append('\t');
                //        stats.append(Integer.toString(edge_idx));
                //        stats.append('/');
                //        stats.append(main_tree.getNode(edge_idx).newickName());
                //        stats.append(".");
                //        stats.append(P.lineage_loss_events[edge_idx]);
                //    }
                //}
                stats.append("\tDuplication:");
                for (int edge_idx=0; edge_idx<num_edges;edge_idx++)
                {
                    if (P.duplication_events[edge_idx]!=0)
                    {
                        stats.append('\t');
                        stats.append(Integer.toString(edge_idx));
                        stats.append('/');
                        stats.append(main_tree.getNode(edge_idx).newickName());
                        stats.append(".");
                        stats.append(P.duplication_events[edge_idx]);
                    }
                }
                stats.append("\tLoss:");
                for (int edge_idx=0; edge_idx<num_edges;edge_idx++)
                {
                    if (P.loss_events[edge_idx]!=0)
                    {
                        stats.append('\t');
                        stats.append(Integer.toString(edge_idx));
                        stats.append('/');
                        stats.append(main_tree.getNode(edge_idx).newickName());
                        stats.append(".");
                        stats.append(P.loss_events[edge_idx]);
                    }
                }
                Verbose.message(stats.toString());
                for (int edge_idx=0; edge_idx<num_edges;edge_idx++)
                {
                    int parent_idx = main_tree.getParentIndex(edge_idx);
                    String parent_size = Integer.toString(P.sizes[parent_idx]);
                    String child_size = Integer.toString(P.sizes[edge_idx]);
                    String key = parent_size+":"+child_size;
                    if (population_size_changes.get(edge_idx).containsKey(key))
                    {
                        int was = population_size_changes.get(edge_idx).get(key).intValue();
                        population_size_changes.get(edge_idx).put(key, new Integer(was+1));
                    } else
                    {
                        population_size_changes.get(edge_idx).put(key, new Integer(1));
                    }
                }
            } // debug messages
            if (leaves.length-num_absent>=min_lineages)
            {
                int sum_sizes = P.sumSizes();
                if (sum_sizes<=maximum_family_size)
                {
                    // OK
                    int[] pattern = P.getProfile();
                    table[profile_idx] = pattern;
                    Verbose.message("SE.rT profile "+profile_idx+"\t"+class_idx+"\t"+P.getPatternString());
                    
                    profile_idx++;
                } else
                    Verbose.message("SE.rT profile skip(big) "+profile_idx+"\t"+class_idx+"\t"+P.getPatternString());
            } else
            {
                num_missing++;
                Verbose.message("SE.rT profile skip(small) "+profile_idx+"\t"+class_idx+"\t"+P.getPatternString());
            }
            
            // bookkeeping
            total_class[class_idx]++;
            for (int node_idx=0; node_idx<num_nodes; node_idx++)
            {
                int x = P.sizes[node_idx];
                if (x==1)
                    total_present_1[node_idx]++;
                else if (x>1)
                    total_present_m[node_idx]++;
            }
            for (int edge_idx=0; edge_idx<num_edges; edge_idx++)
            {
                int parent_idx = main_tree.getParentIndex(edge_idx);
                int px = P.sizes[parent_idx];
                int x = P.sizes[edge_idx];
                if (x==0 && px>0)
                    total_loss[edge_idx]++;
                else if (px==0 && x>0)
                    total_gain[edge_idx]++;
                else if (px>1 && x==1)
                    total_reduction[edge_idx]++;
                else if (px==1 && x>1)
                    total_expansion[edge_idx]++;
            }
        } // profiles
        if (Verbose.isVerbose())
        {
            for (int edge_idx=0; edge_idx<main_tree.getNumEdges(); edge_idx++)
            {
                String node_str = edge_idx+"/"+main_tree.getNode(edge_idx).newickName();
                Hashtable<String,Integer> pop = population_size_changes.get(edge_idx);
                String[] keys = (String[]) pop.keySet().toArray(new String[0]);
                Arrays.sort(keys);
                for (int i=0; i<keys.length; i++)
                    Verbose.message("SE.rT EVENTS\ttotal\t"+node_str+"\t"+keys[i]+"\t"+pop.get(keys[i]));
            }
        }
        
        { // print totals
            StringBuffer total_header = new StringBuffer("#TOTAL\tmissing");
            for (int class_idx =0 ; class_idx<rates.getNumClasses(); class_idx++)
                if (rates.getClassProbability(class_idx)!=0.0)
                {
                    int cat_dup = rates.getDuplicationRateCategory(class_idx);
                    int cat_loss = rates.getLossRateCategory(class_idx);
                    int cat_trans = rates.getTransferRateCategory(class_idx);
                    int cat_edge = rates.getEdgeLengthCategory(class_idx);
                    String name = "C"+Integer.toString(class_idx)+"/e"+cat_edge+",d"+cat_dup+",l"+cat_loss+",t"+cat_trans;
                    total_header.append("\t"+name);
                }
            for (int node_idx=0; node_idx<num_nodes; node_idx++)
            {
                NodeWithRates N  = main_tree.getNode(node_idx);
                String name = N.newickName();
                //System.out.print("\t"+name+":0");
                total_header.append("\t"+name+":1");
                total_header.append("\t"+name+":m");
                if (!N.isRoot())
                {
                    total_header.append("\t"+name+":gain");
                    total_header.append("\t"+name+":loss");
                    total_header.append("\t"+name+":expansion");
                    total_header.append("\t"+name+":reduction");
                }
            }
            System.out.println(total_header.toString());
            StringBuffer total_data = new StringBuffer("#TOTAL");
            total_data.append("\t"+num_missing);
            for (int class_idx =0 ; class_idx<rates.getNumClasses(); class_idx++)
                if (rates.getClassProbability(class_idx)!=0.0)
                {
                    total_data.append("\t");
                    total_data.append(Integer.toString(total_class[class_idx]));
                }
            
            for (int node_idx=0; node_idx<num_nodes; node_idx++)
            {
                NodeWithRates N  = main_tree.getNode(node_idx);
                String name = N.newickName();
                //System.out.print("\t"+name+":0");
                total_data.append("\t"+total_present_1[node_idx]);
                total_data.append("\t"+total_present_m[node_idx]);
                if (!N.isRoot())
                {
                    total_data.append("\t"+total_gain[node_idx]);
                    total_data.append("\t"+total_loss[node_idx]);
                    total_data.append("\t"+total_expansion[node_idx]);
                    total_data.append("\t"+total_reduction[node_idx]);
                }
            }
            System.out.println(total_data.toString());
        }
        
        OccurrenceTable O = new OccurrenceTable(leaves);
        O.setTable(table);
        
        return O;
    }
        
    /**
     * A local class for tracking individuals along a branch.
     * Every Mortal has two timers: one for duplication and another for
     * death. In addition, they store a reference time point (current_time)
     * relative to which duplication and death events are to occur.  
     */
    private class Mortal implements Comparable<Mortal>
    {
        private Mortal()
        {
            this(0.0);
        }
        
        private Mortal(double time)
        {
            hour_of_love = hour_of_death = Double.POSITIVE_INFINITY;
            current_time = time;
            progenitor = this;
        }
        
        private void setSpawnTime(double x)
        {
            this.hour_of_love = x;
        }
        
        private void setDeathTime(double x)
        {
            this.hour_of_death = x;
        }
        
        private boolean dies()
        {
            return hour_of_death < hour_of_love;
        }
        
        
        private double getEventTime()
        {
            return current_time+earliestEvent();
        }
        
        private double hour_of_love;
        private double hour_of_death;
        
        private double current_time;
        
        private Mortal progenitor;
        
        private Mortal spawn()
        {
            current_time += hour_of_love;
            hour_of_death -= hour_of_love;
            hour_of_love = 0.0;
            Mortal child = new Mortal(current_time);
            child.progenitor = progenitor;
            return child;
        }
        
        public int compareTo(Mortal another)
        {
            double anothers_time = another.getEventTime();
            double my_time = getEventTime();
            return Double.compare(my_time, anothers_time);
        }       
        
        private double earliestEvent()
        {
            return Math.min(hour_of_love, hour_of_death);
        }
        
        @Override
        public String toString()
        {
            return "Mortal["+getEventTime()+", t "+current_time+", d "+hour_of_death+", l "+hour_of_love+"]";
        }
    }
    
    /**
     * A phyletic profile with information about the 
     * profile's history, which is known
     * since the profile is produced by simulation.
     */
    public class SimulatedProfile extends PhyleticProfile
    {
        private SimulatedProfile()
        {
            super();
            main_tree = rates.getMainTree();
            int num_edges = main_tree.getNumEdges();
            transfer_events = new int[num_edges];
            loss_events = new int[num_edges]; 
            duplication_events = new int[num_edges];
            lineage_loss_events = new int[num_edges];
            sizes = new int[main_tree.getNumNodes()];
        }
        
        private int[] transfer_events;
        private int[] loss_events;
        private int[] duplication_events;
        private int[] lineage_loss_events;
        private int[] sizes;
        private TreeWithRates main_tree;
        
        /**
         * Size of the family at the given node.
         * 
         * @param node_idx index of a node in the tree
         * @return size at the node in the simulation run
         */
        public int getSize(int node_idx)
        {
            return sizes[node_idx];
        }
        
        
        private void setPatternAtLeaves()
        {
            int[] pattern = new int[main_tree.getNumLeaves()];
            for (int leaf_idx=0; leaf_idx<pattern.length; leaf_idx++)
                pattern[leaf_idx] = sizes[leaf_idx];
            setProfile(pattern);
        }
        
        
    }
    
    /*
    public int[] randomCopyNumbers()
    {
        int[] copy_numbers=new int[dft.length];
        copy_numbers[dft.length-1]=stableCopies(root);
        Verbose.message("SE.rCN root "+copy_numbers[dft.length-1]);
        for (int node_idx=dft.length-2; node_idx>=0;node_idx--){
            NodeWithRates N=dft[node_idx];
            int transferred = transferredCopies(N);
            int parent_copy_number = copy_numbers[parent_idx[node_idx]];
            int inherited = inheritedCopies(N, parent_copy_number);
            copy_numbers[node_idx]=transferred+inherited;
            Verbose.message("SE.rCN "+N.getTaxonName()+" transferred "+transferred+" inherited "+inherited);
        }
        
        int[] leaf_copies=new int[leaves.length];
        {
            int leaf_idx=0;
            for (int node_idx=0; node_idx<dft.length; node_idx++)
                if (dft[node_idx].isLeaf()){
                    leaf_copies[leaf_idx]=copy_numbers[node_idx];
                    leaf_idx++;
                }
        }
        
        return leaf_copies;
    }
    
    private int stableCopies(NodeWithRates N){
        double kappa=N.getTransferRate();
        double lambda=N.getGainRate();
        double mu=N.getLossRate();
        
        double theta = kappa/lambda;
        double lm = lambda/mu;
        double p=0.0; // probability mass function
        double F=p; // cumulative distribution function
        // set copy number at root
        double rnd = RND.nextDouble();
        for (int n=0; ; n++){
            if (n == 0)
                p = Math.pow(1.-lm,theta);
            else
                p *= lm*(theta+n-1.0)/((double)n);
            F+=p;
            
            if (rnd<=F){
                return n;
            }
        }
    }
    
    private int inheritedCopies(NodeWithRates N, int parent_copies){
        double kappa=root.getTransferRate();
        double lambda=root.getGainRate();
        double mu=root.getLossRate();
        
        double theta = kappa/lambda;
        double beta = N.getBeta();
        double lb = lambda*beta;
        
        double[] rnd=new double[parent_copies];
        for (int i=0; i<parent_copies; i++)
            rnd[i]=RND.nextDouble();
        
        
        double p=0.0; // pmf
        double F=0.0; // cdf
        
        int n=0; // copies at N
        int num_copies_dealt_with=0;
        
        for (int m=0; num_copies_dealt_with<parent_copies; m++){
            if (m==0){
                p= mu*beta;
            } else if(m==1){
                p=(1.-mu*beta)*(1-lb);
            } else if (m>1){
                p *= lb;
            }
            F+=p;
            for (int i=0; i<parent_copies; i++)
                if (rnd[i]<=F){
                    n += m;
                    num_copies_dealt_with++;
                    rnd[i]=2.0; // so that it's not included again
            }
            Verbose.message("SE.iC "+N.getTaxonName()+" "+m+" got "+num_copies_dealt_with+" F "+F+" p "+p);
        }
        
        return n;
    }
    
    private int transferredCopies(NodeWithRates N){
        double kappa=root.getTransferRate();
        double lambda=root.getGainRate();
        double mu=root.getLossRate();
        
        double theta = kappa/lambda;
        double beta = N.getBeta();
        double lb = lambda*beta;
        
        double rnd = RND.nextDouble();
        double p=0.0;
        double F=0.0;
        for (int n=0; ;n++){
            if (n==0)
                p=Math.pow(1.0-lb,theta);
            else
                p *= lb*(theta+n-1.0)/((double)n);
            F += p;
            Verbose.message("SE.tC "+N.getTaxonName()+" "+n+" rnd "+rnd+" F "+F+" p "+p);
            if (rnd<=F)
                return n;
        }
    }
     */

    private void go(String[] args) throws Exception
    {
        if (args.length !=3)
        {
            System.err.println("Call as java "+getClass().getCanonicalName()+" [-max_paralogs n -min_lineages k] tree <rate file> length");
            System.exit(2008);
        }
        
        reportLaunch(args);
        reportOtherArguments("Max. paralogs "+MAX_PARALOGS+", min. lineages "+MIN_PRESENT_LINEAGES);
        
        String tree_file = args[0];
        
        TreeWithRates main_tree = new TreeWithRates(ca.umontreal.iro.evolution.Parser.readNewick(new java.io.FileReader(tree_file)));
        String rate_file = args[1];
        int num_families = Integer.parseInt(args[2]);

        RateVariation RV = RateVariation.read(new java.io.FileReader(rate_file), main_tree);
        setRateVariation(RV);
        
        OccurrenceTable Ot = randomTable(MAX_PARALOGS, MIN_PRESENT_LINEAGES, num_families);
        System.out.println(Ot.getFormattedTable());
    }

    private static int MAX_PARALOGS = 150;
    private static int MIN_PRESENT_LINEAGES = 1;
    
    public static void main(String[] args) throws Exception
    {
        Verbose.setVerbose(false);
                
        SimulatedEvolution O = new SimulatedEvolution(); 
        
        int num_switches = 0;
        try {
            while (args.length>2*num_switches && args[2*num_switches].startsWith("-"))
            {
                String arg_switch = args[2*num_switches].substring(1);
                if (arg_switch.equals("h"))
                    O.go(new String[0]); // will throw an Exception
                if (args.length==2*num_switches+1)
                    throw new IllegalArgumentException("Missing argument for switch "+args[2*num_switches]);
                String arg_value = args[2*num_switches+1];
                if (arg_switch.equals("v"))
                {
                    Verbose.setVerbose(arg_value.equals("true"));
                } else if (arg_switch.equals("max_paralogs"))
                {
                    MAX_PARALOGS = Integer.parseInt(arg_value);
                } else if (arg_switch.equals("min_lineages"))
                {
                    MIN_PRESENT_LINEAGES = Integer.parseInt(arg_value);
                } 
                else 
                    throw new IllegalArgumentException("Switch not recognized: '"+args[2*num_switches]+"'");
                    
                num_switches++;
            }
            
            String[] rest=new String[args.length-2*num_switches];
            for (int j=0; j<rest.length; j++)
                rest[j]=args[2*num_switches+j];
            O.go(rest);
        } catch (Exception E)
        {
            die(E);
        }        
    }
}
